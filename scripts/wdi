#!/usr/bin/env bash
#
# wdi - White Doe Inn CLI for standards-aware project bootstrapping
#
# Installation:
#   curl -sSL https://raw.githubusercontent.com/whitedoeinn/dev-plugins-workflow/main/scripts/wdi | bash -s install
#
# Usage:
#   wdi <command> [options]
#
# Commands:
#   install         Install wdi CLI to PATH
#   config          Configure organization-specific values
#   doctor          Check environment and install dependencies
#   create_project  Create a new project following standards
#   update          Update wdi CLI to latest version
#   help            Show this help
#   version         Show version
#
# Environment Variables:
#   WDI_DEBUG=1     Enable debug output for troubleshooting

set -e

VERSION="1.0.0"
WDI_HOME="${HOME}/.config/wdi"
WDI_CONFIG="${WDI_HOME}/config.json"
WDI_BIN="${HOME}/.local/bin/wdi"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ============================================================================
# Utility Functions
# ============================================================================

info() {
  echo -e "${CYAN}→${NC} $1"
}

success() {
  echo -e "${GREEN}✓${NC} $1"
}

warn() {
  echo -e "${YELLOW}⚠️${NC}  $1"
}

error() {
  echo -e "${RED}✗${NC} $1"
}

prompt() {
  echo -e "${BLUE}?${NC} $1"
}

debug() {
  if [[ "${WDI_DEBUG:-}" == "1" ]]; then
    echo -e "${YELLOW}[DEBUG]${NC} $1" >&2
  fi
}

# Check if a command exists
has_command() {
  command -v "$1" >/dev/null 2>&1
}

# Detect OS and package manager
detect_environment() {
  OS=""
  PKG_MANAGER=""

  if [[ "$OSTYPE" == "darwin"* ]]; then
    OS="macos"
    if has_command brew; then
      PKG_MANAGER="brew"
    fi
  elif [[ -n "$WSL_DISTRO_NAME" ]]; then
    OS="wsl"
    PKG_MANAGER="apt"
  elif [[ -f /etc/debian_version ]]; then
    OS="debian"
    PKG_MANAGER="apt"
  elif [[ -f /etc/redhat-release ]]; then
    OS="rhel"
    if has_command dnf; then
      PKG_MANAGER="dnf"
    else
      PKG_MANAGER="yum"
    fi
  else
    OS="unknown"
  fi
}

# Get shell rc file
get_shell_rc() {
  case "$SHELL" in
    */zsh) echo "${HOME}/.zshrc" ;;
    */bash)
      if [[ -f "${HOME}/.bash_profile" ]]; then
        echo "${HOME}/.bash_profile"
      else
        echo "${HOME}/.bashrc"
      fi
      ;;
    */fish) echo "${HOME}/.config/fish/config.fish" ;;
    *) echo "${HOME}/.profile" ;;
  esac
}

# Read config value
config_get() {
  local key="$1"
  local default="$2"
  if [[ -f "$WDI_CONFIG" ]] && has_command jq; then
    local value
    value=$(jq -r ".$key // empty" "$WDI_CONFIG" 2>/dev/null)
    if [[ -n "$value" ]]; then
      echo "$value"
      return
    fi
  fi
  echo "$default"
}

# Read config array
config_get_array() {
  local key="$1"
  if [[ -f "$WDI_CONFIG" ]] && has_command jq; then
    jq -r ".$key[]? // empty" "$WDI_CONFIG" 2>/dev/null
  fi
}

# ============================================================================
# Command: install
# ============================================================================

cmd_install() {
  debug "cmd_install() called"
  echo ""
  echo -e "${CYAN}Installing wdi CLI...${NC}"
  echo ""

  # Create bin directory
  debug "Creating directory: ${HOME}/.local/bin"
  mkdir -p "${HOME}/.local/bin"

  # Download fresh copy from GitHub (stdin is consumed by bash when piped)
  local install_url="https://raw.githubusercontent.com/whitedoeinn/dev-plugins-workflow/main/scripts/wdi"
  debug "Downloading from: $install_url"

  if ! curl -sSL "$install_url" -o "$WDI_BIN"; then
    error "Failed to download wdi script"
    exit 1
  fi

  chmod +x "$WDI_BIN"
  debug "Installed to $WDI_BIN"
  success "Installed to $WDI_BIN"

  # Add to PATH if needed
  local shell_rc
  shell_rc=$(get_shell_rc)

  if ! echo "$PATH" | grep -q "${HOME}/.local/bin"; then
    info "Adding ~/.local/bin to PATH in $shell_rc"

    case "$SHELL" in
      */fish)
        echo 'set -gx PATH $HOME/.local/bin $PATH' >> "$shell_rc"
        ;;
      *)
        echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$shell_rc"
        ;;
    esac

    success "PATH updated (restart shell or run: source $shell_rc)"
  else
    success "~/.local/bin already in PATH"
  fi

  # Create config directory
  mkdir -p "$WDI_HOME"

  echo ""
  info "Running wdi doctor..."
  echo ""

  # Run doctor (need to call via the installed path since we might not be in PATH yet)
  "$WDI_BIN" doctor || true

  # Check if config exists, if not run config
  if [[ ! -f "$WDI_CONFIG" ]]; then
    echo ""
    info "Running initial configuration..."
    echo ""
    "$WDI_BIN" config
  fi

  # Collect manual steps needed (git config is handled by doctor prompts)
  local manual_steps=()

  # Check gh auth
  if command -v gh &>/dev/null; then
    if ! gh auth status &>/dev/null; then
      manual_steps+=("Run 'gh auth login' to authenticate with GitHub")
    fi
  fi

  # Check claude
  if ! command -v claude &>/dev/null; then
    manual_steps+=("Install Claude Code from https://claude.ai/download")
  fi

  # Show summary
  echo ""
  echo "========================================"
  echo -e "${GREEN}Installation complete!${NC}"
  echo "========================================"
  echo ""

  if [[ ${#manual_steps[@]} -gt 0 ]]; then
    echo -e "${YELLOW}Manual steps required:${NC}"
    echo ""
    for i in "${!manual_steps[@]}"; do
      echo "  $((i+1)). ${manual_steps[$i]}"
    done
    echo ""
  fi

  echo "Then run 'wdi create_project' to create a new project."
  echo ""
}

# ============================================================================
# Command: config
# ============================================================================

cmd_config() {
  debug "cmd_config() called"
  echo ""
  echo -e "${CYAN}WDI Configuration${NC}"
  echo ""

  debug "Creating config directory: $WDI_HOME"
  mkdir -p "$WDI_HOME"

  # GitHub org
  local current_org
  current_org=$(config_get "github_org" "")
  prompt "GitHub organization name${current_org:+ [$current_org]}:"
  read -r github_org
  github_org="${github_org:-$current_org}"

  # Project directory
  local current_dir
  current_dir=$(config_get "project_dir" "$HOME/vscode-projects")
  prompt "Default project location [$current_dir]:"
  read -r project_dir
  project_dir="${project_dir:-$current_dir}"
  # Expand ~ to $HOME
  project_dir="${project_dir/#\~/$HOME}"

  # Business domains
  local current_domains
  current_domains=$(config_get_array "business_domains" | tr '\n' ',' | sed 's/,$//')
  current_domains="${current_domains:-marketing, operations, finance, guest-services}"
  prompt "Business domains for repos (comma-separated) [$current_domains]:"
  read -r business_domains
  business_domains="${business_domains:-$current_domains}"

  # Plugin domains
  local current_plugin_domains
  current_plugin_domains=$(config_get_array "plugin_domains" | tr '\n' ',' | sed 's/,$//')
  current_plugin_domains="${current_plugin_domains:-workflow, frontend, backend, analytics, data}"
  prompt "Plugin domains (comma-separated) [$current_plugin_domains]:"
  read -r plugin_domains
  plugin_domains="${plugin_domains:-$current_plugin_domains}"

  # Convert comma-separated to JSON arrays
  local bd_json pd_json
  bd_json=$(echo "$business_domains" | tr ',' '\n' | sed 's/^ *//;s/ *$//' | jq -R . | jq -s .)
  pd_json=$(echo "$plugin_domains" | tr ',' '\n' | sed 's/^ *//;s/ *$//' | jq -R . | jq -s .)

  # Write config
  cat > "$WDI_CONFIG" << EOF
{
  "github_org": "$github_org",
  "project_dir": "$project_dir",
  "business_domains": $bd_json,
  "plugin_domains": $pd_json
}
EOF

  echo ""
  success "Configuration saved to $WDI_CONFIG"
  echo ""
}

# ============================================================================
# Command: doctor
# ============================================================================

cmd_doctor() {
  debug "cmd_doctor() called with args: $*"
  local auto_fix=true
  case "$1" in
    --check-only) auto_fix=false ;;
    --auto-fix) auto_fix=true ;;
  esac
  debug "auto_fix=$auto_fix"

  local has_issues=false

  echo ""
  echo -e "${CYAN}Checking environment...${NC}"

  detect_environment

  case "$OS" in
    macos) success "macOS detected" ;;
    wsl) success "WSL detected ($WSL_DISTRO_NAME)" ;;
    debian) success "Debian/Ubuntu detected" ;;
    rhel) success "RHEL/Fedora detected" ;;
    *) warn "Unknown OS" ;;
  esac

  if [[ -n "$PKG_MANAGER" ]]; then
    success "Package manager: $PKG_MANAGER"
  else
    if [[ "$OS" == "macos" ]]; then
      error "Homebrew not found"
      echo "  Install with: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
      has_issues=true
    fi
  fi

  echo ""
  echo -e "${CYAN}Checking dependencies...${NC}"

  # Check git
  if has_command git; then
    local git_version
    git_version=$(git --version | awk '{print $3}')
    success "git $git_version"

    # Check git config
    local git_name git_email
    git_name=$(git config --global user.name 2>/dev/null || echo "")
    git_email=$(git config --global user.email 2>/dev/null || echo "")
    if [[ -z "$git_name" ]] || [[ -z "$git_email" ]]; then
      warn "git user.name or user.email not configured"
      if [[ "$auto_fix" == true ]]; then
        echo ""
        if [[ -z "$git_name" ]]; then
          prompt "Enter your name for git commits:"
          read -r git_name
          git config --global user.name "$git_name"
          success "Set git user.name to '$git_name'"
        fi
        if [[ -z "$git_email" ]]; then
          prompt "Enter your email for git commits:"
          read -r git_email
          git config --global user.email "$git_email"
          success "Set git user.email to '$git_email'"
        fi
      else
        echo "  Run: git config --global user.name \"Your Name\""
        echo "  Run: git config --global user.email \"your@email.com\""
      fi
    fi
  else
    error "git not found"
    has_issues=true
    if [[ "$auto_fix" == true ]] && [[ -n "$PKG_MANAGER" ]]; then
      info "Installing git..."
      install_package git
    fi
  fi

  # Check gh
  if has_command gh; then
    local gh_version
    gh_version=$(gh --version | head -1 | awk '{print $3}')

    # Check if authenticated
    if gh auth status >/dev/null 2>&1; then
      local gh_user
      gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "unknown")
      success "gh $gh_version (authenticated as $gh_user)"
    else
      warn "gh $gh_version (not authenticated)"
      if [[ "$auto_fix" == true ]]; then
        info "Run 'gh auth login' to authenticate"
      fi
      has_issues=true
    fi
  else
    error "gh (GitHub CLI) not found"
    has_issues=true
    if [[ "$auto_fix" == true ]] && [[ -n "$PKG_MANAGER" ]]; then
      info "Installing gh..."
      install_package gh
    fi
  fi

  # Check jq
  if has_command jq; then
    local jq_version
    jq_version=$(jq --version | sed 's/jq-//')
    success "jq $jq_version"
  else
    error "jq not found"
    has_issues=true
    if [[ "$auto_fix" == true ]] && [[ -n "$PKG_MANAGER" ]]; then
      info "Installing jq..."
      install_package jq
    fi
  fi

  # Check claude
  if has_command claude; then
    local claude_version
    claude_version=$(claude --version 2>/dev/null | head -1 || echo "installed")
    success "claude $claude_version"
  else
    error "claude (Claude Code CLI) not found"
    echo "  Install from: https://claude.ai/download"
    has_issues=true
  fi

  echo ""
  if [[ "$has_issues" == true ]]; then
    warn "Some issues found. Fix them before running wdi create_project."
    return 1
  else
    success "All checks passed!"
    return 0
  fi
}

# Install a package using the detected package manager
install_package() {
  local package="$1"

  case "$PKG_MANAGER" in
    brew)
      brew install "$package"
      ;;
    apt)
      # gh needs special repo on apt
      if [[ "$package" == "gh" ]]; then
        type -p curl >/dev/null || sudo apt install curl -y
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
        sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
        sudo apt update
      fi
      sudo apt install -y "$package"
      ;;
    dnf)
      sudo dnf install -y "$package"
      ;;
    yum)
      sudo yum install -y "$package"
      ;;
    *)
      error "No package manager available to install $package"
      return 1
      ;;
  esac
}

# ============================================================================
# Command: create_project
# ============================================================================

cmd_create_project() {
  debug "cmd_create_project() called"

  # Check and auto-install prerequisites
  echo ""
  info "Checking prerequisites..."
  debug "Calling cmd_doctor --auto-fix"
  if ! cmd_doctor --auto-fix; then
    echo ""
    error "Prerequisites not met. Please fix the issues above and try again."
    debug "cmd_doctor failed, exiting"
    exit 1
  fi
  debug "cmd_doctor passed"

  # Check config exists
  debug "Checking for config file: $WDI_CONFIG"
  if [[ ! -f "$WDI_CONFIG" ]]; then
    echo ""
    warn "No configuration found. Running 'wdi config' first..."
    debug "Config not found, calling cmd_config"
    cmd_config
  fi

  local github_org project_dir
  github_org=$(config_get "github_org" "")
  project_dir=$(config_get "project_dir" "$PWD")
  debug "github_org=$github_org"
  debug "project_dir=$project_dir"

  if [[ -z "$github_org" ]]; then
    error "GitHub organization not configured. Run 'wdi config'."
    exit 1
  fi

  echo ""
  echo -e "${CYAN}Create New Project${NC}"
  echo ""

  # Phase 1: Interview - Project Type
  echo "What type of project?"
  echo "  1) Claude Code Plugin    (dev-plugins-*)"
  echo "  2) Business Domain Repo  (marketing-ops, finance-ops)"
  echo "  3) Standalone Project    (single-purpose tool)"
  echo "  4) Experiment/Spike      (90-day lifecycle)"
  echo ""
  prompt "Select [1-4]:"
  read -r project_type_num

  local project_type domain_name repo_name description

  case "$project_type_num" in
    1) project_type="plugin" ;;
    2) project_type="business-domain" ;;
    3) project_type="standalone" ;;
    4) project_type="experiment" ;;
    *)
      error "Invalid selection"
      exit 1
      ;;
  esac

  # Phase 1: Interview - Domain/Name
  echo ""
  case "$project_type" in
    plugin)
      echo "What domain does this plugin serve?"
      local i=1
      while IFS= read -r domain; do
        echo "  $i) $domain"
        ((i++))
      done < <(config_get_array "plugin_domains")
      echo "  $i) Other - Custom domain"
      echo ""
      prompt "Select:"
      read -r domain_num

      local domains
      mapfile -t domains < <(config_get_array "plugin_domains")
      if [[ "$domain_num" -le "${#domains[@]}" ]]; then
        domain_name="${domains[$((domain_num-1))]}"
      else
        prompt "Enter custom domain:"
        read -r domain_name
      fi

      repo_name="dev-plugins-${domain_name}"
      ;;

    business-domain)
      echo "Which business domain?"
      local i=1
      while IFS= read -r domain; do
        echo "  $i) $domain"
        ((i++))
      done < <(config_get_array "business_domains")
      echo "  $i) Other - Custom domain"
      echo ""
      prompt "Select:"
      read -r domain_num

      local domains
      mapfile -t domains < <(config_get_array "business_domains")
      if [[ "$domain_num" -le "${#domains[@]}" ]]; then
        domain_name="${domains[$((domain_num-1))]}"
      else
        prompt "Enter custom domain:"
        read -r domain_name
      fi

      repo_name="${domain_name}-ops"
      ;;

    standalone)
      prompt "Project name (lowercase-with-hyphens):"
      read -r repo_name
      ;;

    experiment)
      prompt "Experiment name (will be prefixed with 'experiment-'):"
      read -r domain_name
      repo_name="experiment-${domain_name}"
      ;;
  esac

  # Description
  echo ""
  prompt "One-line description for the repository:"
  read -r description

  # Phase 2: Name Proposal
  echo ""
  echo "Based on your answers, the recommended name is:"
  echo ""
  echo -e "    ${GREEN}${repo_name}${NC}"
  echo ""
  echo "This follows REPO-STANDARDS.md:"
  case "$project_type" in
    plugin)
      echo "  ✓ Plugin repos use: dev-plugins-{domain}"
      ;;
    business-domain)
      echo "  ✓ Business domain repos use: {domain}-ops"
      ;;
    standalone)
      echo "  ✓ Standalone repos use descriptive names"
      ;;
    experiment)
      echo "  ✓ Experiment repos use: experiment-{name}"
      ;;
  esac
  echo "  ✓ Lowercase with hyphens"
  echo "  ✓ No wdi- prefix (org provides context)"
  echo ""

  prompt "Accept this name? [Y/n/m]odify:"
  read -r accept_name

  case "${accept_name,,}" in
    n|no)
      echo "Aborted."
      exit 0
      ;;
    m|modify)
      prompt "Enter your preferred name:"
      read -r custom_name
      # Phase 3: Validation
      validate_name "$custom_name" "$project_type"
      repo_name="$custom_name"
      ;;
  esac

  # Phase 5: Create & Initialize
  local project_path="${project_dir}/${repo_name}"

  echo ""
  echo -e "${CYAN}Creating project...${NC}"
  echo ""

  # Check if directory exists
  if [[ -d "$project_path" ]]; then
    error "Directory already exists: $project_path"
    prompt "Overwrite? [y/N]:"
    read -r overwrite
    if [[ "${overwrite,,}" != "y" ]]; then
      exit 1
    fi
    rm -rf "$project_path"
  fi

  # Check if GitHub repo exists
  if gh repo view "${github_org}/${repo_name}" >/dev/null 2>&1; then
    error "GitHub repo already exists: ${github_org}/${repo_name}"
    exit 1
  fi

  # Create directory
  mkdir -p "$project_path"
  cd "$project_path"
  success "Created directory: $project_path"

  # Initialize git
  git init -q
  success "Initialized git"

  # Create structure based on type
  create_project_structure "$project_type" "$repo_name" "$description"

  # Create GitHub repo
  info "Creating GitHub repo..."
  gh repo create "${github_org}/${repo_name}" --private --description "$description" --source=. --push
  success "Created GitHub repo: ${github_org}/${repo_name}"

  # Install wdi plugin (for plugins and other projects)
  info "Installing wdi plugin..."
  if [[ -f "install.sh" ]]; then
    ./install.sh >/dev/null 2>&1 || true
  else
    # Download and run install.sh for non-plugin projects
    curl -sSL https://raw.githubusercontent.com/whitedoeinn/dev-plugins-workflow/main/install.sh | bash -s project >/dev/null 2>&1 || true
  fi
  success "Installed wdi plugin"

  echo ""
  echo -e "${GREEN}Project created successfully!${NC}"
  echo ""
  echo "Location: $project_path"
  echo "GitHub:   https://github.com/${github_org}/${repo_name}"
  echo ""

  prompt "Open in Claude Code? [Y/n]:"
  read -r open_claude
  if [[ "${open_claude,,}" != "n" ]]; then
    cd "$project_path"
    claude
  fi
}

# Validate custom name against standards
validate_name() {
  local name="$1"
  local project_type="$2"
  local issues=()

  # Check lowercase
  if [[ "$name" =~ [A-Z] ]]; then
    issues+=("Must be lowercase")
  fi

  # Check for underscores
  if [[ "$name" == *"_"* ]]; then
    issues+=("Use hyphens, not underscores")
  fi

  # Check for wdi- prefix
  if [[ "$name" == wdi-* ]]; then
    issues+=("Don't use wdi- prefix (org provides context)")
  fi

  # Check pattern based on type
  case "$project_type" in
    plugin)
      if [[ "$name" != dev-plugins-* ]]; then
        issues+=("Plugin repos should use: dev-plugins-{domain}")
      fi
      ;;
    business-domain)
      if [[ "$name" != *-ops ]]; then
        issues+=("Business domain repos should use: {domain}-ops")
      fi
      ;;
    experiment)
      if [[ "$name" != experiment-* ]]; then
        issues+=("Experiment repos should use: experiment-{name}")
      fi
      ;;
  esac

  if [[ ${#issues[@]} -gt 0 ]]; then
    echo ""
    warn "Name \"$name\" doesn't match the standard."
    echo ""
    echo "Issues found:"
    for issue in "${issues[@]}"; do
      echo "  ✗ $issue"
    done
    echo ""
    echo "You can still use this name, but please provide a reason."
    echo ""

    echo "Why does this name work better?"
    echo "  1) Existing convention - Following external/legacy convention"
    echo "  2) Clarity - Standard name would be confusing"
    echo "  3) Integration - Must match external system"
    echo "  4) Standard should change - Naming standard needs updating"
    echo "  5) Other - Custom explanation"
    echo ""
    prompt "Select:"
    read -r reason_num

    local reason_text
    case "$reason_num" in
      1) reason_text="Existing convention" ;;
      2) reason_text="Clarity" ;;
      3) reason_text="Integration" ;;
      4) reason_text="Standard should change" ;;
      5)
        prompt "Please explain:"
        read -r reason_text
        ;;
    esac

    # Store exception (will be added to repo later)
    export WDI_EXCEPTION_NAME="$name"
    export WDI_EXCEPTION_REASON="$reason_text"

    # Create issue if standard should change
    if [[ "$reason_num" == "4" ]]; then
      info "Creating issue to review naming standard..."
      local github_org
      github_org=$(config_get "github_org" "")
      gh issue create \
        --repo "${github_org}/dev-plugins-workflows" \
        --title "Consider naming standard update: $name" \
        --body "## Naming Exception Detected

A new repository was created with a name that deviates from our naming standard.

### Details

| Field | Value |
|-------|-------|
| Repository | \`$name\` |
| Project Type | $project_type |
| User's Reason | $reason_text |

### Suggested Action

Review whether the naming standard should be updated to accommodate this use case.

---
*Auto-generated by wdi create_project*" 2>/dev/null || warn "Could not create issue"
    fi
  fi
}

# Create project structure based on type
create_project_structure() {
  local project_type="$1"
  local repo_name="$2"
  local description="$3"
  local today
  today=$(date +%Y-%m-%d)

  case "$project_type" in
    plugin)
      create_plugin_structure "$repo_name" "$description"
      ;;
    business-domain|standalone|experiment)
      create_standard_structure "$repo_name" "$description" "$project_type"
      ;;
  esac

  # Add naming exception if one was recorded
  if [[ -n "${WDI_EXCEPTION_NAME:-}" ]]; then
    mkdir -p .github
    cat > .github/naming-exceptions.md << EOF
# Naming Exceptions

This repository's name deviates from standard conventions.

## Exception Details

| Field | Value |
|-------|-------|
| Standard Pattern | (see REPO-STANDARDS.md) |
| Actual Name | \`${WDI_EXCEPTION_NAME}\` |
| Reason | ${WDI_EXCEPTION_REASON} |
| Date | ${today} |
| Created By | wdi CLI |
EOF
  fi

  success "Created project structure"

  # Initial commit
  git add -A
  git commit -q -m "chore: Initialize ${project_type} repository

Set up standard directory structure and documentation.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
  success "Created initial commit"
}

# Create plugin structure
create_plugin_structure() {
  local repo_name="$1"
  local description="$2"
  local today
  today=$(date +%Y-%m-%d)

  # Directories
  mkdir -p .claude-plugin commands skills hooks knowledge scripts docs

  # .claude-plugin/plugin.json
  cat > .claude-plugin/plugin.json << EOF
{
  "name": "${repo_name}",
  "description": "${description}",
  "version": "0.1.0",
  "commands": "./commands/",
  "skills": "./skills/",
  "hooks": "./hooks/hooks.json"
}
EOF

  # .claude-plugin/marketplace.json
  cat > .claude-plugin/marketplace.json << EOF
{
  "marketplaces": []
}
EOF

  # hooks/hooks.json
  cat > hooks/hooks.json << EOF
{
  "hooks": []
}
EOF

  # install.sh
  cat > install.sh << 'EOF'
#!/usr/bin/env bash
set -e

echo "Installing plugin..."

# Install compound-engineering dependency
claude plugin marketplace add https://github.com/EveryInc/compound-engineering-plugin 2>/dev/null || true
claude plugin install compound-engineering --scope project 2>/dev/null || true

# Install wdi dependency
claude plugin marketplace add https://github.com/whitedoeinn/dev-plugins-workflow 2>/dev/null || true
claude plugin install wdi --scope project 2>/dev/null || true

echo "Installation complete!"
EOF
  chmod +x install.sh

  # CLAUDE.md
  cat > CLAUDE.md << EOF
# ${repo_name}

${description}

## Commands

(Add commands here as you create them)

## Setup

Run \`./install.sh\` to install dependencies.
EOF

  # README.md
  cat > README.md << EOF
# ${repo_name}

${description}

## Installation

\`\`\`bash
curl -sSL https://raw.githubusercontent.com/whitedoeinn/${repo_name}/main/install.sh | bash
\`\`\`

## Usage

(Add usage instructions)

## Development

See [CLAUDE.md](CLAUDE.md) for development instructions.
EOF

  # CONTRIBUTING.md
  cat > CONTRIBUTING.md << EOF
# Contributing

## Development

1. Clone this repository
2. Make changes to commands in \`commands/\`
3. Test locally - changes take effect immediately
4. Submit a PR

## Standards

Follow the conventions in [CLAUDE.md](CLAUDE.md).
EOF

  # docs/changelog.md
  cat > docs/changelog.md << EOF
# Changelog

All notable changes documented here.

---

## ${today}

### Added
- Initial project setup
EOF

  # docs/troubleshooting.md
  cat > docs/troubleshooting.md << EOF
# Troubleshooting

## Common Issues

(Add troubleshooting guides as issues arise)
EOF

  # .gitignore
  cat > .gitignore << EOF
.DS_Store
*.log
node_modules/
.env
EOF
}

# Create standard structure (business-domain, standalone, experiment)
create_standard_structure() {
  local repo_name="$1"
  local description="$2"
  local project_type="$3"
  local today
  today=$(date +%Y-%m-%d)

  # Directories
  mkdir -p packages shared src tests scripts docs

  # CLAUDE.md
  cat > CLAUDE.md << EOF
# ${repo_name}

${description}

## Structure

\`\`\`
${repo_name}/
├── packages/       # Multi-package support
├── shared/         # Common utilities
├── src/            # Main source code
├── tests/          # Test files
├── scripts/        # Build and utility scripts
└── docs/           # Documentation
\`\`\`

## Development

(Add development instructions)
EOF

  # README.md
  local experiment_notice=""
  if [[ "$project_type" == "experiment" ]]; then
    local expiry_date
    expiry_date=$(date -v+90d +%Y-%m-%d 2>/dev/null || date -d "+90 days" +%Y-%m-%d 2>/dev/null || echo "TBD")
    experiment_notice="
> ⚠️ **Experiment**: This repo has a 90-day lifecycle.
> Created: ${today} | Review by: ${expiry_date}
> Promote to permanent repo or archive with documented learnings.
"
  fi

  cat > README.md << EOF
# ${repo_name}
${experiment_notice}
${description}

## Getting Started

(Add getting started instructions)

## Development

See [CLAUDE.md](CLAUDE.md) for development instructions.
EOF

  # docs/changelog.md
  cat > docs/changelog.md << EOF
# Changelog

All notable changes documented here.

---

## ${today}

### Added
- Initial project setup
EOF

  # .gitignore
  cat > .gitignore << EOF
.DS_Store
*.log
node_modules/
.env
__pycache__/
*.pyc
.venv/
EOF
}

# ============================================================================
# Command: update
# ============================================================================

cmd_update() {
  echo ""
  info "Updating wdi CLI..."
  curl -sSL https://raw.githubusercontent.com/whitedoeinn/dev-plugins-workflow/main/scripts/wdi | bash -s install
}

# ============================================================================
# Command: help
# ============================================================================

cmd_help() {
  cat << EOF

${CYAN}wdi${NC} - White Doe Inn CLI for standards-aware project bootstrapping

${YELLOW}Usage:${NC}
  wdi <command> [options]

${YELLOW}Commands:${NC}
  install         Install wdi CLI to PATH
  config          Configure organization-specific values
  doctor          Check environment and install dependencies
  create_project  Create a new project following standards
  update          Update wdi CLI to latest version
  help            Show this help
  version         Show version

${YELLOW}Examples:${NC}
  wdi create_project                    # Interactive project creation
  wdi doctor                            # Check/fix environment
  wdi config                            # Reconfigure settings

${YELLOW}Installation:${NC}
  curl -sSL https://raw.githubusercontent.com/whitedoeinn/dev-plugins-workflow/main/scripts/wdi | bash -s install

EOF
}

# ============================================================================
# Command: version
# ============================================================================

cmd_version() {
  echo "wdi version $VERSION"
}

# ============================================================================
# Main
# ============================================================================

main() {
  debug "main() called with args: $*"
  debug "WDI_HOME=$WDI_HOME"
  debug "WDI_CONFIG=$WDI_CONFIG"
  debug "WDI_BIN=$WDI_BIN"

  local command="${1:-help}"
  shift || true

  debug "Executing command: $command"

  case "$command" in
    install) cmd_install "$@" ;;
    config) cmd_config "$@" ;;
    doctor) cmd_doctor "$@" ;;
    create_project) cmd_create_project "$@" ;;
    update) cmd_update "$@" ;;
    help|--help|-h) cmd_help ;;
    version|--version|-v) cmd_version ;;
    *)
      error "Unknown command: $command"
      cmd_help
      exit 1
      ;;
  esac
}

main "$@"
